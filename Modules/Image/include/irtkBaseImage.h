/* The Image Registration Toolkit (IRTK)
 *
 * Copyright 2008-2015 Imperial College London
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. */

#ifndef _IRTKBASEIMAGE_H
#define _IRTKBASEIMAGE_H

#include <irtkVoxel.h>
#include <irtkImageAttributes.h>
#ifdef HAS_VTK
#  include <irtkVTK.h>
#  include <vtkStructuredPoints.h>
#endif


////////////////////////////////////////////////////////////////////////////////
// Forward declaration of used specialized image types
////////////////////////////////////////////////////////////////////////////////

template <class VoxelType> class irtkGenericImage;
/// Binary image as used for masks (0: off, otherwise: on)
typedef irtkGenericImage<irtkBinaryPixel>  irtkBinaryImage;

/// FIXME: Use irtkDouble3 as voxel type instead
typedef irtkGenericImage<double>           irtkWorldCoordsImage;

////////////////////////////////////////////////////////////////////////////////
// Definition of base image class
////////////////////////////////////////////////////////////////////////////////

/**
 * Abstract generic class for 2D or 3D images
 *
 * This abstract base class provides generic support for 2D and 3D image
 * classes. It provides functions for accessing image dimension and origin
 * as well as voxel dimensions. It also provides functions for conversion
 * between image and world coordinates.
 */

class irtkBaseImage : public irtkObject
{
  irtkAbstractMacro(irtkBaseImage);

  // ---------------------------------------------------------------------------
  // Attributes

protected:

  /// Image attributes
  irtkImageAttributes _attr;

  /// Total number of voxels
  int _NumberOfVoxels;

  /// Transformation matrix from image coordinates to (transformed) world coordinates
  irtkMatrix _matI2W;

  /// Transformation matrix from (transformed) world coordinates to image coordinates
  irtkMatrix _matW2I;

  /// Foreground mask
  irtkBinaryImage *_mask;

  /// Whether this image owns the mask image
  ///
  /// Set to a value above 1 when mask was generated by InitializeMask,
  /// in which case the mask will be deleted by the n-th ClearMask call,
  /// where n is the number of preceeding (nested) InitializeMask calls.
  /// A value of 1 denotes a mask image set by the owner which this image
  /// should delete upon destruction.
  int _maskOwner;

  /// Background value - may also be NaN for floating point images
  double _bg;

  /// Whether a background value was set
  bool _bgSet;

  // ---------------------------------------------------------------------------
  // Construction/Destruction

  /// Default constructor
  irtkBaseImage();

  /// Constructor
  irtkBaseImage(const irtkImageAttributes &, int = 1);

  /// Copy constructor
  irtkBaseImage(const irtkBaseImage &);

public:

  /// Destructor
  virtual ~irtkBaseImage();

  // ---------------------------------------------------------------------------
  // Initialization

  /// Read file and construct image
  static irtkBaseImage *New(const char *);
  
  /// Construct image copy of same type
  static irtkBaseImage *New(const irtkBaseImage *);

  /// Construct image with given voxel type
  static irtkBaseImage *New(int);

  /// Create copy of this image
  virtual irtkBaseImage *Copy() const;

protected:

  /// Update coordinate transformation
  void UpdateMatrix();

  /// Puts attributes of image
  void PutAttributes(const irtkImageAttributes &);

public:

  /// Initialize image
  virtual void Initialize(const irtkImageAttributes &, int = -1) = 0;

  /// Assignment operator
  irtkBaseImage &operator =(const irtkBaseImage &);

  /// Clear image
  virtual void Clear() = 0;

  // ---------------------------------------------------------------------------
  // Lattice

  /// Gets the image attributes
  const irtkImageAttributes &Attributes() const;

  /// Returns the total number of voxels
  int NumberOfVoxels() const;

  /// Returns the total number of spatial voxels
  int NumberOfSpatialVoxels() const;

  /// Returns the number of voxels in the x-direction
  int X() const;
  
  /// Returns the number of voxels in the y-direction
  int Y() const;
  
  /// Returns the number of voxels in the z-direction
  int Z() const;
  
  /// Returns the number of voxels in the t-direction
  int T() const;

  /// Returns the number of vector components (i.e., 1 for scalar images)
  virtual int N() const;

  /// Returns the number of voxels in the x-direction
  int GetX() const;

  /// Returns the number of voxels in the y-direction
  int GetY() const;

  /// Returns the number of voxels in the z-direction
  int GetZ() const;

  /// Returns the number of voxels in the t-direction
  int GetT() const;

  /// Returns the size of a voxel in the x-direction
  double GetXSize() const;

  /// Returns the size of a voxel in the y-direction
  double GetYSize() const;

  /// Returns the size of a voxel in the z-direction
  double GetZSize() const;

  /// Returns the size of a voxel in the t-direction
  double GetTSize() const;

  /// Set temporal voxel size, i.e., to zero for vector field and non-zero for temporal sequence
  void PutTSize(double);

  /// Voxel dimensions get access
  void GetPixelSize(double &, double &) const;

  /// Voxel dimensions get access
  void GetPixelSize(double &, double &, double &) const;

  /// Voxel dimensions get access
  void GetPixelSize(double &, double &, double &, double &) const;

  /// Voxel dimensions put access
  void PutPixelSize(double, double, double);

  /// Voxel dimensions put access
  void PutPixelSize(double, double, double, double);

  /// Image origin get access
  irtkPoint GetOrigin() const;

  /// Image origin get access
  void GetOrigin(double &, double &, double &) const;

  /// Image origin get access
  void GetOrigin(double &, double &, double &, double &) const;

  /// Image origin put access
  void PutOrigin(const irtkPoint &);

  /// Image origin put access
  void PutOrigin(double, double, double);

  /// Image origin put access
  void PutOrigin(double, double, double, double);

  /// Put temporal origin
  void PutTOrigin(double);
  
  /// Get temporal origin
  double GetTOrigin() const;

  /// Put image x- and y-axis and z-axis
  void PutOrientation(double *, double *, double * = NULL);

  /// Get image x- and y-axis and z-axis
  void GetOrientation(double *, double *, double * = NULL) const;

  /// Get orientation of axis relative to patient
  void Orientation(int &, int &, int &) const;

  /// Put affine world coordinate transformation which is applied
  /// after the image to world coordinate transformation derived from the
  /// imaging geometry when mapping voxel indices to world coordinates.
  /// This transformation can be the inverse of the affine transformation
  /// obtained by an affine registration with this image as source.
  void PutAffineMatrix(const irtkMatrix &, bool = false);

  /// Reset affine world coordinate transformation which is applied
  /// after the image to world coordinate transformation derived from the
  /// imaging geometry when mapping voxel indices to world coordinates.
  void ResetAffineMatrix();

  /// Get affine world coordinate transformation which is applied
  /// after the image to world coordinate transformation derived from the
  /// imaging geometry when mapping voxel indices to world coordinates
  const irtkMatrix &GetAffineMatrix() const;

  /// Function to convert pixel to index
  int VoxelToIndex(int, int, int = 0, int = 0) const;
  
  /// Function to convert index to pixel coordinates
  void IndexToVoxel(int, int &, int &) const;
  
  /// Function to convert index to pixel coordinates
  void IndexToVoxel(int, int &, int &, int &) const;
  
  /// Function to convert index to pixel coordinates
  void IndexToVoxel(int, int &, int &, int &, int &) const;

  /// Get world coordinates (in mm) of pixl
  void IndexToWorld(int, double &, double &) const;

  /// Get world coordinates (in mm) of pixel
  void IndexToWorld(int, double &, double &, double &) const;

  /// Get world coordinates (in mm) of pixel
  void IndexToWorld(int, irtkPoint &) const;

  /// Get world coordinates (in mm) of pixel
  irtkPoint IndexToWorld(int) const;

  /// Image to world coordinate conversion with two doubles
  void ImageToWorld(double &, double &) const;

  /// Image to world coordinate conversion with three doubles
  void ImageToWorld(double &, double &, double &) const;

  /// Image to world coordinate conversion with a given point
  void ImageToWorld(irtkPoint &) const;

  /// Image to world coordinate map for image domain
  ///
  /// \note Stores x, y, and z components as vector image,
  ///       i.e., in t dimension of image.
  ///
  /// \param[out] i2w Vector image with world coordinates of voxels.
  ///                 Need not be initialized before. No reallocation
  ///                 takes place if the image has already the right size.
  /// \param[in] _3D  If \c false, only the x and y coordinates are
  ///                 stored if the image is two dimensional. Otherwise,
  ///                 all three x, y, and z components are stored.
  void ImageToWorld(irtkWorldCoordsImage &i2w, bool _3D = true) const;

  /// Image to world coordinate map for image domain
  ///
  /// \note Stores x, y, and z components at consecutive memory
  ///       locations for faster access.
  ///
  /// \param[out] i2w Memory for pre-computed world coordinates.
  /// \param[in] _3D  If \c false, only the x and y coordinates are
  ///                 stored if the image is two dimensional. Otherwise,
  ///                 all three x, y, and z components are stored.
  void ImageToWorld(double *i2w, bool _3D = true) const;

  /// World to image coordinate conversion with two doubles
  void WorldToImage(double &, double &) const;

  /// World to image coordinate conversion with three doubles
  void WorldToImage(double &, double &, double &) const;
  
  /// World to image coordinate conversion with a given point
  void WorldToImage(irtkPoint &) const;

  /// Return transformation matrix for image to world coordinates
  const irtkMatrix &GetImageToWorldMatrix() const;
  
  /// Return transformation matrix for world to image coordinates
  const irtkMatrix &GetWorldToImageMatrix() const;

  /// Image to time coordinate conversion
  double ImageToTime(double) const;

  /// Time to image coordinate conversion
  double TimeToImage(double) const;

  /// Checks if this image shares the same spatial attributes with another image
  bool HasSpatialAttributesOf(const irtkBaseImage *) const;

  /// Returns true if point is within the field of view of image
  bool IsInFOV(double, double, double);
  
  /// Whether image is uninitialized
  bool IsEmpty() const;

  // ---------------------------------------------------------------------------
  // Type independent access to image data

  /// Function for pixel get access as double
  virtual double GetAsDouble(int) const;
  
  /// Function for pixel get access as double
  virtual double GetAsDouble(int, int, int = 0, int = 0) const = 0;
  
  /// Function for pixel put access
  virtual void PutAsDouble(int, double);
  
  /// Function for pixel put access
  virtual void PutAsDouble(int, int, double);
  
  /// Function for pixel put access
  virtual void PutAsDouble(int, int, int, double);

  /// Function for pixel put access
  virtual void PutAsDouble(int, int, int, int, double) = 0;

  /// Function for pixel get access as double
  virtual void GetAsVector(irtkVector &, int) const;

  /// Function for pixel get access as double
  virtual void GetAsVector(irtkVector &, int, int, int = 0, int = 0) const = 0;

  /// Function for pixel get access as double
  virtual irtkVector GetAsVector(int) const;

  /// Function for pixel get access as double
  virtual irtkVector GetAsVector(int, int, int = 0, int = 0) const;

  /// Function for pixel put access
  virtual void PutAsVector(int, const irtkVector &);

  /// Function for pixel put access
  virtual void PutAsVector(int, int, const irtkVector &);

  /// Function for pixel put access
  virtual void PutAsVector(int, int, int, const irtkVector &);

  /// Function for pixel put access
  virtual void PutAsVector(int, int, int, int, const irtkVector &) = 0;

  // ---------------------------------------------------------------------------
  // Foreground region

  /// Set foreground mask
  void PutMask(irtkBinaryImage *, bool = false);

  /// Get foreground mask (optionally, take over ownership)
  irtkBinaryImage *GetMask(bool = false);

  /// Get foreground mask
  const irtkBinaryImage *GetMask() const;

  /// Whether this image has a foreground mask which has been
  /// either set via PutMask or created upon InitializeMask
  bool HasMask() const;

  /// Whether this image has a foreground mask
  /// either set via PutMask with ownership transver or created upon InitializeMask
  bool OwnsMask() const;

  /// Initialize mask if not done yet or none is set
  void InitializeMask(int t = -1, bool = false);

  /// Clear mask upon n-th call after n preceeding InitializeMask calls
  void ClearMask(bool = false);

  /// Put background value
  void PutBackgroundValueAsDouble(double);

  /// Put background value
  virtual void PutBackgroundValueAsDouble(double, bool);

  /// Get background value
  double GetBackgroundValueAsDouble() const;

  /// Clear background value
  void ClearBackgroundValue();

  /// Whether a background value has been set
  bool HasBackgroundValue() const;

  /// Whether voxel is within foreground without index-out-of-bounds check
  bool IsForeground(int) const;

  /// Whether voxel is within foreground without index-out-of-bounds check
  bool IsForeground(int, int, int = 0, int = 0) const;

  /// Whether voxel is within background without index-out-of-bounds check
  bool IsBackground(int) const;

  /// Whether voxel is within background without index-out-of-bounds check
  bool IsBackground(int, int, int = 0, int = 0) const;

  /// Whether voxel is index is within finite image domain
  bool IsInside(int) const;

  /// Whether voxel indices are within finite image domain
  bool IsInside(int, int, int = 0, int = 0) const;

  /// Whether voxel is index is outside finite image domain
  bool IsOutside(int) const;

  /// Whether voxel indices are outside finite image domain
  bool IsOutside(int, int, int = 0, int = 0) const;

  /// Whether voxel is index is within finite image domain and part of foreground region
  bool IsInsideForeground(int) const;

  /// Whether voxel indices are within finite image domain and part of foreground region
  bool IsInsideForeground(int, int, int = 0, int = 0) const;

  /// Whether voxel is index is outside finite image domain or part of background region
  bool IsOutsideForeground(int) const;

  /// Whether voxel indices are outside finite image domain or part of background region
  bool IsOutsideForeground(int, int, int = 0, int = 0) const;

  /// Whether all voxels within a 2D bounding region are inside foreground region
  bool IsBoundingBoxInsideForeground(int, int, int, int) const;

  /// Whether all voxels within a 3D bounding region are inside foreground region
  bool IsBoundingBoxInsideForeground(int, int, int, int, int, int) const;

  /// Whether all voxels within a 4D bounding region are inside foreground region
  bool IsBoundingBoxInsideForeground(int, int, int, int, int, int, int, int) const;

  /// Whether any voxel is within background
  bool HasBackground() const;

  // ---------------------------------------------------------------------------
  // Region-of-interest extraction

  /// Get image consisting of specified 2D slice
  virtual void GetRegion(irtkBaseImage *&, int, int) const = 0;

  /// Get image consisting of specified 3D subregion
  virtual void GetRegion(irtkBaseImage *&, int, int, int, int, int, int) const = 0;

  /// Get image consisting of specified 4D subregion
  virtual void GetRegion(irtkBaseImage *&, int, int, int, int, int, int, int, int) const = 0;

  /// Get time instance (i.e., frame) or channel of image
  virtual void GetFrame(irtkBaseImage *&, int, int = -1) const = 0;

  // ---------------------------------------------------------------------------
  // Common image statistics

  /// Minimum and maximum pixel values get accessor
  virtual void GetMinMaxAsDouble(double &, double &) const;

  /// Minimum and maximum pixel values put accessor
  virtual void PutMinMaxAsDouble(double, double);
  
  // ---------------------------------------------------------------------------
  // Access to raw image data

  /// Function for pixel access via pointers
  virtual void *GetDataPointer(int = 0) = 0;

  /// Function for pixel access via pointers
  virtual const void *GetDataPointer(int = 0) const = 0;

  /// Function for pixel access via pointers
  virtual void *GetDataPointer(int, int, int = 0, int = 0) = 0;
  
  /// Function for pixel access via pointers
  virtual const void *GetDataPointer(int, int, int = 0, int = 0) const = 0;

  /// Function which returns pixel scalar type
  virtual int GetDataType() const = 0;

  /// Function which returns size of pixel scalar type in bytes
  virtual int GetDataTypeSize() const = 0;

  /// Function which returns the minimum value the pixel can hold without overflowing
  virtual double GetDataTypeMin() const = 0;

  /// Function which returns the minimum value the pixel can hold without overflowing
  virtual double GetDataTypeMax() const = 0;

  // ---------------------------------------------------------------------------
  // Common image manipulations
  
  virtual void ReflectX() = 0;  ///< Reflect image along x
  virtual void ReflectY() = 0;  ///< Reflect image along y
  virtual void ReflectZ() = 0;  ///< Reflect image along z
  
  virtual void FlipXY(int) = 0; ///< Flip x and y axis
  virtual void FlipXZ(int) = 0; ///< Flip x and z axis
  virtual void FlipYZ(int) = 0; ///< Flip y and z axis
  virtual void FlipXT(int) = 0; ///< Flip x and t axis
  virtual void FlipYT(int) = 0; ///< Flip y and t axis
  virtual void FlipZT(int) = 0; ///< Flip z and t axis

  // ---------------------------------------------------------------------------
  // VTK interface
#ifdef HAS_VTK

  /// Return the corresponding VTK scalar type
  int ImageToVTKScalarType() const
  {
    return ToVTKDataType(this->GetDataType());
  }

  /// Convert image to VTK structured points
  virtual void ImageToVTK(vtkStructuredPoints *) const = 0;

  /// Convert VTK structured points to image
  virtual void VTKToImage(vtkStructuredPoints *) = 0;

#endif

  // ---------------------------------------------------------------------------
  // I/O

  /// Read image from file
  virtual void Read(const char *) = 0;

  /// Write image to file
  virtual void Write(const char *) const = 0;

  /// Print image information
  virtual void Print(irtkIndent = 0) const;

  // ---------------------------------------------------------------------------
  // Emulation of irtkGenericImage<VoxelType>

  // The following type definitions and "generic" voxel type specific member
  // function are required by image functions/filters which are templated
  // over the image type. If irtkBaseImage is provided as template argument,
  // these functions and filters access the image data (indirectly) through the
  // abstract interface methods with implicit conversion to irtkVector.
  // For improved performance and no data conversion, these image functions
  // and filters can, however, be instantiated with a specific image type
  // such as irtkGreyImage in which case no data conversion takes place.
  //
  // \sa irtkGenericExtrapolateImageFunction, irtkGenericInterpolateImageFunction

  /// Default voxel type used by generic interpolate/extrapolate image functions
  /// when instantiated with irtkBaseImage as template argument as done by the
  /// general interpolate image functions which thus can interpolate any scalar image.
  typedef double                           VoxelType;
  typedef voxel_info<VoxelType>::RealType  RealType;

  /// Get pixel value at voxel with given index
  VoxelType Get(int) const;

  /// Get pixel value at voxel with given lattice coordinates
  VoxelType Get(int, int, int = 0, int = 0) const;

  // ---------------------------------------------------------------------------
  // Deprecated

  /// Gets the image attributes
  /// \deprecated Use Attributes instead.
  const irtkImageAttributes &GetImageAttributes() const;

  /// Returns the total number of voxels
  /// \deprecated Use NumberOfVoxels instead.
  int GetNumberOfVoxels() const;

  /// Voxel dimensions get access
  void GetPixelSize(double *, double *, double *) const;

  /// Voxel dimensions get access
  void GetPixelSize(double *, double *, double *, double *) const;

  /// Minimum and maximum pixel values get accessor
  void GetMinMaxAsDouble(double *, double *) const;

  /// \returns Raw pointer to contiguous image data.
  /// \deprecated Use GetDataPointer instead.
  void *GetScalarPointer(int = 0, int = 0, int = 0, int = 0);

  /// \returns Raw pointer to contiguous image data.
  /// \deprecated Use GetDataPointer instead.
  const void *GetScalarPointer(int = 0, int = 0, int = 0, int = 0) const;

  /// \returns Enumeration value corresponding to pixel scalar type.
  /// \deprecated Use GetVoxelType instead.
  int GetScalarType() const;

  /// \returns Size of pixel scalar type in bytes.
  /// \deprecated Use GetVoxelTypeSize instead.
  int GetScalarTypeSize() const;

  /// \returns Minimum value a pixel can hold without overflowing.
  /// \deprecated Use GetVoxelTypeMin instead.
  double GetScalarTypeMin() const;

  /// \returns Maximum value a pixel can hold without overflowing.
  /// \deprecated Use GetVoxelTypeMax instead.
  double GetScalarTypeMax() const;

};

/// Alternative/backwards compatible type name
typedef irtkBaseImage irtkImage;

////////////////////////////////////////////////////////////////////////////////
// Definition of irtkBinaryImage
////////////////////////////////////////////////////////////////////////////////

// irtkBinaryImage must be completely defined here already such that it can
// be used in the inline definitions. The methods using the mask must be inline
// in order for them to be efficient enough as they will be called for each voxel

#include <irtkVoxel.h>
#include <irtkGeometry.h>
#include <irtkGenericImage.h>

////////////////////////////////////////////////////////////////////////////////
// Inline definitions of irtkBaseImage
////////////////////////////////////////////////////////////////////////////////

// =============================================================================
// Lattice
// =============================================================================

// -----------------------------------------------------------------------------
inline const irtkImageAttributes &irtkBaseImage::Attributes() const
{
  return _attr;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::NumberOfVoxels() const
{
  return _NumberOfVoxels;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::NumberOfSpatialVoxels() const
{
  return _attr.NumberOfSpatialPoints();
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::X() const
{
  return _attr._x;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::Y() const
{
  return _attr._y;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::Z() const
{
  return _attr._z;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::T() const
{
  return _attr._t;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::N() const
{
  return 1;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetX() const
{
  return _attr._x;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetY() const
{
  return _attr._y;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetZ() const
{
  return _attr._z;
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetT() const
{
  return _attr._t;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetXSize() const
{
  return _attr._dx;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetYSize() const
{
  return _attr._dy;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetZSize() const
{
  return _attr._dz;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetTSize() const
{
  return _attr._dt;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutTSize(double dt)
{
  _attr._dt = dt;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutPixelSize(double dx, double dy, double dz)
{
  _attr._dx = dx;
  _attr._dy = dy;
  _attr._dz = dz;
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutPixelSize(double dx, double dy, double dz, double dt)
{
  _attr._dx = dx;
  _attr._dy = dy;
  _attr._dz = dz;
  _attr._dt = dt;
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetPixelSize(double &dx, double &dy) const
{
  dx = _attr._dx;
  dy = _attr._dy;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetPixelSize(double &dx, double &dy, double &dz) const
{
  dx = _attr._dx;
  dy = _attr._dy;
  dz = _attr._dz;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetPixelSize(double &dx, double &dy, double &dz, double &dt) const
{
  dx = _attr._dx;
  dy = _attr._dy;
  dz = _attr._dz;
  dt = _attr._dt;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutOrigin(const irtkPoint &p)
{
  _attr._xorigin = p._x;
  _attr._yorigin = p._y;
  _attr._zorigin = p._z;
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutOrigin(double x, double y, double z)
{
  _attr._xorigin = x;
  _attr._yorigin = y;
  _attr._zorigin = z;
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutOrigin(double x, double y, double z, double t)
{
  _attr._xorigin = x;
  _attr._yorigin = y;
  _attr._zorigin = z;
  _attr._torigin = t;
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetOrigin(double &x, double &y, double &z) const
{
  x = _attr._xorigin;
  y = _attr._yorigin;
  z = _attr._zorigin;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetOrigin(double &x, double &y, double &z, double &t) const
{
  x = _attr._xorigin;
  y = _attr._yorigin;
  z = _attr._zorigin;
  t = _attr._torigin;
}

// -----------------------------------------------------------------------------
inline irtkPoint irtkBaseImage::GetOrigin() const
{
  return irtkPoint(_attr._xorigin, _attr._yorigin, _attr._zorigin);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutTOrigin(double t)
{
  _attr._torigin = t;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetTOrigin() const
{
  return _attr._torigin;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutOrientation(double *xaxis, double *yaxis, double *zaxis)
{
  const size_t n = 3 * sizeof(double);
  memcpy(_attr._xaxis, xaxis, n);
  memcpy(_attr._yaxis, yaxis, n);
  if (zaxis) memcpy(_attr._zaxis, zaxis, n);
  else {
    _attr._zaxis[0] = _attr._xaxis[1] * _attr._yaxis[2] - _attr._xaxis[2] * _attr._yaxis[1];
    _attr._zaxis[1] = _attr._xaxis[2] * _attr._yaxis[0] - _attr._xaxis[0] * _attr._yaxis[2];
    _attr._zaxis[2] = _attr._xaxis[0] * _attr._yaxis[1] - _attr._xaxis[1] * _attr._yaxis[0];
  }
  UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetOrientation(double *xaxis, double *yaxis, double *zaxis) const
{
  const size_t n = 3 * sizeof(double);
  memcpy(xaxis, _attr._xaxis, n);
  memcpy(yaxis, _attr._yaxis, n);
  if (zaxis) memcpy(zaxis, _attr._zaxis, n);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAffineMatrix(const irtkMatrix &mat, bool apply)
{
  _attr.PutAffineMatrix(mat, apply);
  this->UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline const irtkMatrix &irtkBaseImage::GetAffineMatrix() const
{
  return _attr._smat;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::ResetAffineMatrix()
{
  _attr._smat.Ident();
  this->UpdateMatrix();
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::VoxelToIndex(int i, int j, int k, int l) const
{
  return _attr.LatticeToIndex(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToVoxel(int idx, int &i, int &j) const
{
  _attr.IndexToLattice(idx, i, j);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToVoxel(int idx, int &i, int &j, int &k) const
{
  _attr.IndexToLattice(idx, i, j, k);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToVoxel(int idx, int &i, int &j, int &k, int &l) const
{
  _attr.IndexToLattice(idx, i, j, k, l);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToWorld(int idx, double &x, double &y) const
{
  _attr.IndexToWorld(idx, x, y);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToWorld(int idx, double &x, double &y, double &z) const
{
  _attr.IndexToWorld(idx, x, y, z);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::IndexToWorld(int idx, irtkPoint &p) const
{
  _attr.IndexToWorld(idx, p);
}

// -----------------------------------------------------------------------------
inline irtkPoint irtkBaseImage::IndexToWorld(int idx) const
{
  return _attr.IndexToWorld(idx);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::ImageToWorld(double &x, double &y) const
{
  double a = _matI2W(0, 0) * x + _matI2W(0, 1) * y + _matI2W(0, 3);
  double b = _matI2W(1, 0) * x + _matI2W(1, 1) * y + _matI2W(1, 3);
  x = a, y = b;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::ImageToWorld(double &x, double &y, double &z) const
{
  double a = _matI2W(0, 0) * x + _matI2W(0, 1) * y + _matI2W(0, 2) * z + _matI2W(0, 3);
  double b = _matI2W(1, 0) * x + _matI2W(1, 1) * y + _matI2W(1, 2) * z + _matI2W(1, 3);
  double c = _matI2W(2, 0) * x + _matI2W(2, 1) * y + _matI2W(2, 2) * z + _matI2W(2, 3);
  x = a, y = b, z = c;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::ImageToWorld(irtkPoint &p) const
{
  ImageToWorld(p._x, p._y, p._z);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::WorldToImage(double &x, double &y) const
{
  double a = _matW2I(0, 0) * x + _matW2I(0, 1) * y + _matW2I(0, 3);
  double b = _matW2I(1, 0) * x + _matW2I(1, 1) * y + _matW2I(1, 3);
  x = a, y = b;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::WorldToImage(double &x, double &y, double &z) const
{
  double a = _matW2I(0, 0) * x + _matW2I(0, 1) * y + _matW2I(0, 2) * z + _matW2I(0, 3);
  double b = _matW2I(1, 0) * x + _matW2I(1, 1) * y + _matW2I(1, 2) * z + _matW2I(1, 3);
  double c = _matW2I(2, 0) * x + _matW2I(2, 1) * y + _matW2I(2, 2) * z + _matW2I(2, 3);
  x = a, y = b, z = c;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::WorldToImage(irtkPoint &p) const
{
  WorldToImage(p._x, p._y, p._z);
}

// -----------------------------------------------------------------------------
inline const irtkMatrix &irtkBaseImage::GetImageToWorldMatrix() const
{
  return _matI2W;
}

// -----------------------------------------------------------------------------
inline const irtkMatrix &irtkBaseImage::GetWorldToImageMatrix() const
{
  return _matW2I;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::ImageToTime(double t) const
{
  return _attr._torigin + t * _attr._dt;
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::TimeToImage(double t) const
{
  return (_attr._dt ? ((t - _attr._torigin) / _attr._dt) : .0);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::HasSpatialAttributesOf(const irtkBaseImage *other) const
{
  return _attr.EqualInSpace(other->GetImageAttributes());
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsInFOV(double x, double y, double z)
{
  this->WorldToImage(x, y, z);
  return (-0.5 <= x && x < _attr._x - 0.5) &&
         (-0.5 <= y && y < _attr._y - 0.5) &&
         (-0.5 <= z && z < _attr._z - 0.5);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsEmpty() const
{
  return ((_attr._x < 1) || (_attr._y < 1) || (_attr._z < 1) || (_attr._t < 1));
}

// =============================================================================
// Type independent access to image data
// =============================================================================

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetAsDouble(int idx) const
{
  int i, j, k, l;
  IndexToVoxel(idx, i, j, k, l);
  return this->GetAsDouble(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsDouble(int idx, double v)
{
  int i, j, k, l;
  IndexToVoxel(idx, i, j, k, l);
  this->PutAsDouble(i, j, k, l, v);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsDouble(int i, int j, double v)
{
  this->PutAsDouble(i, j, 0, 0, v);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsDouble(int i, int j, int k, double v)
{
  this->PutAsDouble(i, j, k, 0, v);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetAsVector(irtkVector &v, int idx) const
{
  int i, j, k, l;
  IndexToVoxel(idx, i, j, k, l);
  this->GetAsVector(v, i, j, k, l);
}

// -----------------------------------------------------------------------------
inline irtkVector irtkBaseImage::GetAsVector(int idx) const
{
  irtkVector v;
  this->GetAsVector(v, idx);
  return v;
}

// -----------------------------------------------------------------------------
inline irtkVector irtkBaseImage::GetAsVector(int i, int j, int k, int l) const
{
  irtkVector v;
  this->GetAsVector(v, i, j, k, l);
  return v;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsVector(int idx, const irtkVector &v)
{
  int i, j, k, l;
  IndexToVoxel(idx, i, j, k, l);
  this->PutAsVector(i, j, k, l, v);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsVector(int i, int j, const irtkVector &v)
{
  this->PutAsVector(i, j, 0, 0, v);
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutAsVector(int i, int j, int k, const irtkVector &v)
{
  this->PutAsVector(i, j, k, 0, v);
}

// =============================================================================
// Foreground region
// =============================================================================

// -----------------------------------------------------------------------------
inline irtkBinaryImage *irtkBaseImage::GetMask(bool surrender_ownership)
{
  if (surrender_ownership) _maskOwner = false;
  return _mask;
}

// -----------------------------------------------------------------------------
inline const irtkBinaryImage *irtkBaseImage::GetMask() const
{
  return _mask;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::HasMask() const
{
  return _mask != NULL;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::OwnsMask() const
{
  return _mask != NULL && _maskOwner;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutBackgroundValueAsDouble(double value)
{
  _bg    = value;
  _bgSet = true;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::PutBackgroundValueAsDouble(double value, bool threshold)
{
  _bg    = value;
  _bgSet = true;
  if (threshold) {
    for (int idx = 0; idx < _NumberOfVoxels; idx++) {
      if (this->GetAsDouble(idx) < _bg) this->PutAsDouble(idx, _bg);
    }
  }
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetBackgroundValueAsDouble() const
{
  return _bg;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::ClearBackgroundValue()
{
  _bgSet = false;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::HasBackgroundValue() const
{
  return _bgSet;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsForeground(int idx) const
{
  if (_mask) {
    if (_mask->GetT() != _attr._t) idx = idx % (_attr._x * _attr._y * _attr._z);
    return _mask->Get(idx);
  } else if (_bgSet) {
    const double value = this->GetAsDouble(idx);
    return (value != _bg) && (!IsNaN(value) || !IsNaN(_bg));
  }
  return true;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsForeground(int i, int j, int k, int l) const
{
  if (_mask) {
    if (_mask->GetT() != _attr._t) l = 0;
    return _mask->Get(i, j, k, l);
  } else if (_bgSet) {
    const double value = this->GetAsDouble(i, j, k, l);
    return (value != _bg) && (!IsNaN(value) || !IsNaN(_bg));
  }
  return true;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsBackground(int idx) const
{
  return !IsForeground(idx);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsBackground(int i, int j, int k, int l) const
{
  return !IsForeground(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsInside(int idx) const
{
  return (0 <= idx && idx < _NumberOfVoxels);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsInside(int i, int j, int k, int l) const
{
  return (0 <= i && i < _attr._x &&
          0 <= j && j < _attr._y &&
          0 <= k && k < _attr._z &&
          0 <= l && l < _attr._t);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsOutside(int idx) const
{
  return !IsInside(idx);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsOutside(int i, int j, int k, int l) const
{
  return !IsInside(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsInsideForeground(int idx) const
{
  return IsInside(idx) && IsForeground(idx);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsInsideForeground(int i, int j, int k, int l) const
{
  return IsInside(i, j, k, l) && IsForeground(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsOutsideForeground(int idx) const
{
  return !IsInsideForeground(idx);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsOutsideForeground(int i, int j, int k, int l) const
{
  return !IsInsideForeground(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsBoundingBoxInsideForeground(int i1, int j1,
                                                         int i2, int j2) const
{
  if (i1 < 0 || i2 >= _attr._x ||
      j1 < 0 || j2 >= _attr._y) return false;
  if (_mask) {
    for (int j = j1; j != j2; j++) {
      for (int i = i1; i != i2; i++) {
        if (!_mask->Get(i, j)) return false;
      }
    }
  } else if (_bgSet) {
    double value;
    for (int j = j1; j != j2; j++) {
      for (int i = i1; i != i2; i++) {
        value = this->GetAsDouble(i, j);
        if (value == _bg || (IsNaN(value) && IsNaN(_bg))) return false;
      }
    }
  }
  return true;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsBoundingBoxInsideForeground(int i1, int j1, int k1,
                                                         int i2, int j2, int k2) const
{
  if (i1 < 0 || i2 >= _attr._x ||
      j1 < 0 || j2 >= _attr._y ||
      k1 < 0 || k2 >= _attr._z) return false;
  if (_mask) {
    for (int k = k1; k != k2; k++) {
      for (int j = j1; j != j2; j++) {
        for (int i = i1; i != i2; i++) {
          if (!_mask->Get(i, j, k)) return false;
        }
      }
    }
  } else if (_bgSet) {
    double value;
    for (int k = k1; k != k2; k++) {
      for (int j = j1; j != j2; j++) {
        for (int i = i1; i != i2; i++) {
          value = this->GetAsDouble(i, j, k);
          if (value == _bg || (IsNaN(value) && IsNaN(_bg))) return false;
        }
      }
    }
  }
  return true;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::IsBoundingBoxInsideForeground(int i1, int j1, int k1, int l1,
                                                         int i2, int j2, int k2, int l2) const
{
  if (i1 < 0 || i2 >= _attr._x ||
      j1 < 0 || j2 >= _attr._y ||
      k1 < 0 || k2 >= _attr._z ||
      l1 < 0 || l2 >= _attr._t) return false;
  if (_mask) {
    if (_mask->T() == 1) {
      for (int k = k1; k != k2; k++) {
        for (int j = j1; j != j2; j++) {
          for (int i = i1; i != i2; i++) {
            if (!_mask->Get(i, j, k)) return false;
          }
        }
      }
    } else {
      for (int l = l1; l != l2; l++) {
        for (int k = k1; k != k2; k++) {
          for (int j = j1; j != j2; j++) {
            for (int i = i1; i != i2; i++) {
              if (!_mask->Get(i, j, k, l)) return false;
            }
          }
        }
      }
    }
  } else if (_bgSet) {
    double value;
    for (int l = l1; l != l2; l++) {
      for (int k = k1; k != k2; k++) {
        for (int j = j1; j != j2; j++) {
          for (int i = i1; i != i2; i++) {
            value = this->GetAsDouble(i, j, k, l);
            if (value == _bg || (IsNaN(value) && IsNaN(_bg))) return false;
          }
        }
      }
    }
  }
  return true;
}

// -----------------------------------------------------------------------------
inline bool irtkBaseImage::HasBackground() const
{
  if (HasBackgroundValue() || GetMask()) {
    for (int i = 0; i < _NumberOfVoxels; i++) {
      if (IsBackground(i)) return true;
    }
  }
  return false;
}

// =============================================================================
// Emulation of irtkGenericImage<VoxelType>
// =============================================================================

// -----------------------------------------------------------------------------
inline double irtkBaseImage::Get(int idx) const
{
  return this->GetAsDouble(idx);
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::Get(int i, int j, int k, int l) const
{
  return this->GetAsDouble(i, j, k, l);
}

// =============================================================================
// Deprecated
// =============================================================================

// -----------------------------------------------------------------------------
inline const irtkImageAttributes &irtkBaseImage::GetImageAttributes() const
{
  return Attributes();
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetNumberOfVoxels() const
{
  return NumberOfVoxels();
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetPixelSize(double *dx, double *dy, double *dz) const
{
  *dx = _attr._dx;
  *dy = _attr._dy;
  *dz = _attr._dz;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetPixelSize(double *dx, double *dy, double *dz, double *dt) const
{
  *dx = _attr._dx;
  *dy = _attr._dy;
  *dz = _attr._dz;
  *dt = _attr._dt;
}

// -----------------------------------------------------------------------------
inline void irtkBaseImage::GetMinMaxAsDouble(double *min, double *max) const
{
  this->GetMinMaxAsDouble(*min, *max);
}

// -----------------------------------------------------------------------------
inline void *irtkBaseImage::GetScalarPointer(int i, int j, int k, int l)
{
  return this->GetDataPointer(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline const void *irtkBaseImage::GetScalarPointer(int i, int j, int k, int l) const
{
  return this->GetDataPointer(i, j, k, l);
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetScalarType() const
{
  return this->GetDataType();
}

// -----------------------------------------------------------------------------
inline int irtkBaseImage::GetScalarTypeSize() const
{
  return this->GetDataTypeSize();
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetScalarTypeMin() const
{
  return this->GetDataTypeMin();
}

// -----------------------------------------------------------------------------
inline double irtkBaseImage::GetScalarTypeMax() const
{
  return this->GetDataTypeMax();
}


#endif
